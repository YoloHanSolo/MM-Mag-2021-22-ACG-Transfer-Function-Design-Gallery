{"Photon":"struct Photon {\n    vec3 position;\n    vec3 direction;\n    vec3 transmittance;\n    vec3 radiance;\n    uint bounces;\n    uint samples;\n};\n","XYZITU2002":"vec3 rgb2xyz(vec3 rgb) {\n    const mat3 RGB2XYZ = mat3(\n        0.412453, 0.357580, 0.180423,\n        0.212671, 0.715160, 0.072169,\n        0.019334, 0.119193, 0.950227\n    );\n\n    return RGB2XYZ * rgb;\n}\n\nvec3 xyz2rgb(vec3 xyz) {\n    const mat3 XYZ2RGB = mat3(\n         3.240481, -1.537152, -0.498536,\n        -0.969255,  1.875990,  0.041556,\n         0.055647, -0.204041,  1.057311\n    );\n\n    return XYZ2RGB * xyz;\n}\n\nvec3 xyz2xyY(vec3 xyz) {\n    float sum = xyz.x + xyz.y + xyz.z;\n    return xyz.xyy / vec3(sum, sum, 1.0);\n}\n\nvec3 xyY2xyz(vec3 xyY) {\n    return vec3(xyY.x, xyY.y, 1.0 - xyY.x - xyY.y) * xyY.z / xyY.y;\n}\n","YUVBT601":"vec3 rgb2yuv(vec3 rgb) {\n    const mat3 RGB2YUV = mat3(\n         0.29900, -0.14713,  0.61500,\n         0.58700, -0.28886, -0.51499,\n         0.11400,  0.43600, -0.10001\n    );\n\n    return RGB2YUV * rgb;\n}\n\nvec3 yuv2rgb(vec3 yuv) {\n    const mat3 YUV2RGB = mat3(\n         1.00000,  1.00000,  1.00000,\n         0.00000, -0.39465,  2.03211,\n         1.13983, -0.58060,  0.00000\n    );\n\n    return YUV2RGB * yuv;\n}\n","YUVBT709":"vec3 rgb2yuv(vec3 rgb) {\n    const mat3 RGB2YUV = mat3(\n         0.21260, -0.09991,  0.61500,\n         0.71520, -0.33609, -0.55861,\n         0.07220,  0.43600, -0.05639\n    );\n\n    return RGB2YUV * rgb;\n}\n\nvec3 yuv2rgb(vec3 yuv) {\n    const mat3 YUV2RGB = mat3(\n         1.00000,  1.00000,  1.00000,\n         0.00000, -0.21482,  2.12798,\n         1.28033, -0.38059,  0.00000\n    );\n\n    return YUV2RGB * yuv;\n}\n","btrand":"float btrand(inout vec4 n) {\n    const vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\n    const vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\n    const vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\n    const vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\n\n    vec4 beta = floor(n / q);\n    vec4 p = a * (n - beta * q) - beta * r;\n    beta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;\n    n = (p + beta);\n\n    return fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\n}\n","encodeFloat":"highp float shiftRight(highp float v, highp float amt) {\n    v = floor(v) + 0.5;\n    return floor(v / exp2(amt));\n}\n\nhighp float shiftLeft(highp float v, highp float amt) {\n    return floor(v * exp2(amt) + 0.5);\n}\n\nhighp float maskLast(highp float v, highp float bits) {\n    return mod(v, shiftLeft(1.0, bits));\n}\n\nhighp float extractBits(highp float num, highp float from, highp float to) {\n    from = floor(from + 0.5); to = floor(to + 0.5);\n    return maskLast(shiftRight(num, from), to - from);\n}\n\nlowp vec4 encodeFloat(highp float val) {\n    if (val == 0.0) {\n        return vec4(0.0);\n    }\n    highp float sgn = val > 0.0 ? 0.0 : 1.0;\n    val = abs(val);\n    highp float exponent = floor(log2(val));\n    highp float biasedExponent = exponent + 127.0;\n    highp float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\n    highp float t = biasedExponent / 2.0;\n    highp float lastBitOfBiasedExponent = fract(t) * 2.0;\n    highp float remainingBitsOfBiasedExponent = floor(t);\n    highp float byte4 = extractBits(fraction, 0.0, 8.0) / 255.0;\n    highp float byte3 = extractBits(fraction, 8.0, 16.0) / 255.0;\n    highp float byte2 = (lastBitOfBiasedExponent * 128.0 + extractBits(fraction, 16.0, 23.0)) / 255.0;\n    highp float byte1 = (sgn * 128.0 + remainingBitsOfBiasedExponent) / 255.0;\n    return vec4(byte4, byte3, byte2, byte1);\n}\n","floatToRgba":"vec4 floatToRgba(float x) {\n    const vec4 encoder = vec4(1.0, 255.0, 255.0 * 255.0, 255.0 * 255.0 * 255.0);\n    const vec4 corrector = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n    vec4 enc = fract(x * encoder);\n    return enc - enc.yzww * corrector;\n}\n","hue":"#define HUE_PART 0.16666666666666\nvec4 hue(float x) {\n    float r = smoothstep(1.0 * HUE_PART, 2.0 * HUE_PART, x) - smoothstep(4.0 * HUE_PART, 5.0 * HUE_PART, x);\n    float g = smoothstep(0.0 * HUE_PART, 1.0 * HUE_PART, x) - smoothstep(3.0 * HUE_PART, 4.0 * HUE_PART, x);\n    float b = smoothstep(2.0 * HUE_PART, 3.0 * HUE_PART, x) - smoothstep(5.0 * HUE_PART, 6.0 * HUE_PART, x);\n    return vec4(1.0 - r, g, b, 1.0);\n}\n","intersectCube":"vec2 intersectCube(in vec3 origin, in vec3 direction) {\n    vec3 tmin = (vec3(0.0) - origin) / direction;\n    vec3 tmax = (vec3(1.0) - origin) / direction;\n    vec3 t1 = min(tmin, tmax);\n    vec3 t2 = max(tmin, tmax);\n    float tnear = max(max(t1.x, t1.y), t1.z);\n    float tfar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tnear, tfar);\n}\n","rand":"vec2 rand(vec2 p) {\n    const mat2 M = mat2(\n        23.14069263277926, 2.665144142690225,\n        12.98987893203892, 78.23376739376591);\n    const vec2 D = vec2(\n        1235.6789,\n        4378.5453);\n    vec2 dotted = M * p;\n    vec2 mapped = vec2(cos(dotted.x), sin(dotted.y));\n    return fract(mapped * D);\n}\n","rgbaToFloat":"float rgbaToFloat(vec4 x) {\n    const vec4 decoder = 1.0 / vec4(1.0, 255.0, 255.0 * 255.0, 255.0 * 255.0 * 255.0);\n    return dot(x, decoder);\n}\n","unproject":"void unproject(in vec2 position, in mat4 inverseMvp, out vec3 from, out vec3 to) {\n    vec4 nearPosition = vec4(position, -1.0, 1.0);\n    vec4 farPosition = vec4(position, 1.0, 1.0);\n    vec4 fromDirty = inverseMvp * nearPosition;\n    vec4 toDirty = inverseMvp * farPosition;\n    from = fromDirty.xyz / fromDirty.w;\n    to = toDirty.xyz / toDirty.w;\n}\n","unprojectRand":"void unprojectRand(\n        inout vec2 randState,\n        in vec2 position,\n        in mat4 inverseMvp,\n        in vec2 inverseResolution,\n        in float blur,\n        out vec3 from, out vec3 to)\n{\n    // sample a disk on the near plane (depth of field)\n    const float TWOPI = 2.0 * 3.14159265358979323;\n    randState = rand(randState);\n    float u1 = TWOPI * randState.x;\n    float u2 = sqrt(randState.y);\n    vec2 offset = vec2(cos(u1), sin(u1)) * u2 * blur;\n    vec4 nearPosition = vec4(position + offset, -1.0, 1.0);\n\n    // sample a square on the far plane (antialiasing)\n    randState = rand(randState);\n    vec2 antialiasing = (randState * 2.0 - 1.0) * inverseResolution;\n    vec4 farPosition = vec4(position + antialiasing, 1.0, 1.0);\n\n    // map to world space\n    vec4 fromDirty = inverseMvp * nearPosition;\n    vec4 toDirty = inverseMvp * farPosition;\n    from = fromDirty.xyz / fromDirty.w;\n    to = toDirty.xyz / toDirty.w;\n}\n","wang":"uint wang(uint seed) {\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n"}